{"version":3,"file":"static/js/676.530f2747.chunk.js","mappings":"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","sources":["searchWorker.js"],"sourcesContent":["/* eslint-disable no-restricted-globals */\r\n// src/searchWorker.js\r\n\r\nlet directMap = {}, variantMap = {}, patternMap = {}, joyoSet = new Set(), oldNewMap = {};\r\n\r\nconst MAX_CANDIDATES = 100; // 上位100件を抽出\r\n\r\nself.onmessage = ({ data }) => {\r\n  // ───── 初期化 ─────\r\n  if (data.init) {\r\n    directMap   = data.directMap;\r\n    variantMap  = data.variantMap;\r\n    patternMap  = data.patternMap;\r\n    joyoSet     = new Set(data.joyoList);\r\n    oldNewMap   = data.oldNewMap;\r\n    console.log('▷ worker INIT received:', {\r\n      directSize: Object.keys(directMap).length,\r\n      variantSize: Object.keys(variantMap).length,\r\n      patternSize: Object.keys(patternMap).length\r\n    });\r\n    return;\r\n  }\r\n\r\n  const { parts, mode, region } = data;\r\n\r\n  // ───── 1. 部品→漢字モード：単一漢字入力の早期返却 ─────\r\n  if (mode === 'partsToKanji' && parts.length === 1) {\r\n    const p = parts[0];\r\n    // directMap から候補を取得（なければ空配列）\r\n    let results = Array.isArray(directMap[p]) ? [...directMap[p]] : [];\r\n    // 「自身」を先頭に挿入\r\n    if (!results.includes(p)) {\r\n      results.unshift(p);\r\n    }\r\n    // joyo/japanese フィルター\r\n    if (region === 'joyo') {\r\n      results = results.filter(k => joyoSet.has(k));\r\n    } else if (region === 'japanese') {\r\n      results = results.filter(k => joyoSet.has(k) || oldNewMap[k]);\r\n    }\r\n    postMessage({ results });\r\n    return;\r\n  }\r\n\r\n  // ───── 2. 漢字→部品モード：全パターンをマージ ─────\r\n  if (mode === 'kanjiToParts' && parts.length > 0) {\r\n    const out = [];\r\n    const seen = new Set();\r\n\r\n    // patternMap[漢字] は [ [層1の配列], [層2の配列], ... ]\r\n    const layers = patternMap[parts.join('')] || [];\r\n\r\n    // ⬇︎ 各層ごとに「漢字だけ」をフィルタ\r\n    const layersKanji = layers.map(layer =>\r\n      layer.filter(p => p.charCodeAt(0) > 0x007F)\r\n    );\r\n    const layers_afterExtKanji = layersKanji;\r\n\r\n    layers_afterExtKanji.forEach(layer => {\r\n      layer.forEach(p => {\r\n        if (!seen.has(p)) {\r\n          seen.add(p);\r\n          out.push(p);\r\n        }\r\n      });\r\n    });\r\n\r\n    postMessage({ results: out });\r\n    return;\r\n  }\r\n\r\n  // ───── 3. 以下、元々の部品→漢字ロジック ─────\r\n  // 0) patternMap による暗黙の分解\r\n  const expanded = [];\r\n  parts.forEach(p => {\r\n    if (!directMap[p] && patternMap[p]) {\r\n      const pats = patternMap[p];\r\n      if (pats.length > 0) expanded.push(...pats[0]);\r\n      else expanded.push(p);\r\n    } else {\r\n      expanded.push(p);\r\n    }\r\n  });\r\n  const rawParts = [...new Set(expanded)];\r\n\r\n  // 1) 異体字も含めた配列を作成\r\n  const variantArrays = rawParts.map(ch => [ch, ...(variantMap[ch] || [])]);\r\n\r\n  // 2) 全組み合わせを生成\r\n  const cartesianProduct = arrays =>\r\n    arrays.reduce((acc, curr) => acc.flatMap(prev => curr.map(item => [...prev, item])), [[]]);\r\n  const combos = cartesianProduct(variantArrays);\r\n\r\n  // 3) 逆引きインデックス（directMap）でマッチ数をカウント\r\n  const matchCountMap = new Map();\r\n  combos.forEach(combo => {\r\n    const sets = combo.map(p => {\r\n      const list = directMap[p];\r\n      return new Set(Array.isArray(list) && list.length > 0 ? list : [p]);\r\n    });\r\n    if (!sets.length) return;\r\n    const intersection = sets.reduce((a, b) => new Set([...a].filter(k => b.has(k))));\r\n    intersection.forEach(k => {\r\n      matchCountMap.set(k, (matchCountMap.get(k) || 0) + 1);\r\n    });\r\n  });\r\n\r\n  // 4) 上位100件を抽出\r\n  // const candidates = Array.from(matchCountMap.entries())\r\n  //   .sort((a, b) => b[1] - a[1])\r\n  //   .slice(0, 100)\r\n  //   .map(([k]) => k);\r\n\r\n  // // 5) スコア計算\r\n  // const calculateScore = (patArr, inParts) => {\r\n  //   const total = patArr.filter(ch => /\\p{Script=Han}/u.test(ch)).length;\r\n  //   if (!total) return 0;\r\n  //   const cnt = {};\r\n  //   inParts.forEach(x => (cnt[x] = (cnt[x] || 0) + 1));\r\n  //   let match = 0;\r\n  //   Object.entries(cnt).forEach(([p, n]) => {\r\n  //     const occ = patArr.reduce((s, c) => (c === p ? s + 1 : s), 0);\r\n  //     match += Math.min(n, occ);\r\n  //   });\r\n  //   const rate = (match / total) * 100;\r\n  //   const exact = patArr.length >= inParts.length && inParts.every((p, i) => patArr[i] === p);\r\n  //   return rate + (exact ? 50 : 0);\r\n  // };\r\n  // const scored = candidates\r\n  //   .map(k => {\r\n  //     const patterns = patternMap[k] || [];\r\n  //     const best = patterns.reduce((m, arr) => Math.max(m, calculateScore(arr, rawParts)), 0);\r\n  //     return { k, score: best };\r\n  //   })\r\n  //   .sort((a, b) => b.score - a.score)\r\n  //   .map(x => x.k);\r\n\r\n  // // 6) joyo/japanese フィルター\r\n  // let filtered = scored;\r\n  // if (mode === 'partsToKanji') {\r\n  //   if (region === 'joyo') {\r\n  //     filtered = filtered.filter(k => joyoSet.has(k));\r\n  //   } else if (region === 'japanese') {\r\n  //     filtered = filtered.filter(k => joyoSet.has(k) || oldNewMap[k]);\r\n  //   }\r\n  // }\r\n\r\n\r\n  // 4) joyo/japanese フィルター\r\n  let filtered = Array.from(matchCountMap.keys());\r\n  if (mode === 'partsToKanji') {\r\n    if (region === 'joyo') {\r\n      filtered = filtered.filter(k => joyoSet.has(k));\r\n    } else if (region === 'japanese') {\r\n      filtered = filtered.filter(k => joyoSet.has(k) || oldNewMap[k]);\r\n    }\r\n  }\r\n\r\n  // 5) スコア計算\r\n  const calculateScore = (patArr, inParts) => {\r\n    const total = patArr.filter(ch => /\\p{Script=Han}/u.test(ch)).length;\r\n    if (!total) return 0;\r\n    const cnt = {};\r\n    inParts.forEach(x => (cnt[x] = (cnt[x] || 0) + 1));\r\n    let match = 0;\r\n    Object.entries(cnt).forEach(([p, n]) => {\r\n      const occ = patArr.reduce((s, c) => (c === p ? s + 1 : s), 0);\r\n      match += Math.min(n, occ);\r\n    });\r\n    const rate = (match / total) * 100;\r\n    const exact = patArr.length >= inParts.length && inParts.every((p, i) => patArr[i] === p);\r\n    return rate + (exact ? 50 : 0);\r\n  };\r\n  const scoredObjs = filtered.map(k => {\r\n    const patterns = patternMap[k] || [];\r\n    // 各パターンで最高スコアを求める\r\n    const best = patterns.reduce((m, arr) => Math.max(m, calculateScore(arr, rawParts)), 0);\r\n    return { k, score: best };\r\n  });\r\n\r\n  // 6) 上位100件を抽出\r\n  const candidates = scoredObjs\r\n    .sort((a, b) => b.score - a.score)\r\n    .slice(0, MAX_CANDIDATES)\r\n    .map(o => o.k);\r\n\r\n  // 7) 最終返却\r\n  postMessage({ results: candidates });\r\n};\r\n"],"names":["directMap","variantMap","patternMap","joyoSet","Set","oldNewMap","self","onmessage","_ref","data","init","joyoList","console","log","directSize","Object","keys","length","variantSize","patternSize","parts","mode","region","p","results","Array","isArray","includes","unshift","filter","k","has","postMessage","out","seen","join","map","layer","charCodeAt","forEach","add","push","expanded","pats","rawParts","variantArrays","ch","combos","reduce","acc","curr","flatMap","prev","item","matchCountMap","Map","combo","sets","list","a","b","set","get","filtered","from","candidates","score","m","arr","Math","max","calculateScore","patArr","inParts","total","test","cnt","x","match","entries","_ref2","n","occ","s","c","min","every","i","sort","slice","o"],"sourceRoot":""}